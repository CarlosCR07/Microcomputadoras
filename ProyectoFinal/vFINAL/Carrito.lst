CCS PCM C Compiler, Version 5.076, 2401               27-jun.-23 18:50

               Filename:   D:\carlo\Documentos\FI\8vo Semestre\Micro-computadoras\Microcomputadoras\ProyectoFinal\vFINAL\Carrito.lst

               ROM used:   1029 words (13%)
                           Largest free fragment is 2048
               RAM used:   31 (8%) at main() level
                           50 (14%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   2A5
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   06D
.................... #include <16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  28
0056:  RETLW  0C
0057:  RETLW  01
0058:  RETLW  06
*
00AA:  DATA 20,28
00AB:  DATA F2,3A
00AC:  DATA 65,31
00AD:  DATA 61,10
00AE:  DATA 0A,10
00AF:  DATA 00,00
00B0:  DATA AD,16
00B1:  DATA AD,16
00B2:  DATA 41,36
00B3:  DATA F4,37
00B4:  DATA AD,16
00B5:  DATA AD,16
00B6:  DATA 20,05
00B7:  DATA 20,00
00B8:  DATA 20,10
00B9:  DATA 41,3B
00BA:  DATA 61,37
00BB:  DATA FA,30
00BC:  DATA AD,16
00BD:  DATA AD,16
00BE:  DATA 2D,10
00BF:  DATA 0A,10
00C0:  DATA 00,01
00C1:  DATA 20,10
00C2:  DATA D2,32
00C3:  DATA 74,39
00C4:  DATA EF,31
00C5:  DATA 65,32
00C6:  DATA E5,16
00C7:  DATA AD,16
00C8:  DATA AD,16
00C9:  DATA 20,05
00CA:  DATA 20,00
00CB:  DATA 20,10
00CC:  DATA 49,3D
00CD:  DATA F1,3A
00CE:  DATA E9,32
00CF:  DATA 72,32
00D0:  DATA E1,16
00D1:  DATA AD,16
00D2:  DATA AD,16
00D3:  DATA 2D,10
00D4:  DATA 0A,10
00D5:  DATA 00,01
00D6:  DATA 20,10
00D7:  DATA C4,32
00D8:  DATA F2,32
00D9:  DATA 63,34
00DA:  DATA E1,16
00DB:  DATA AD,16
00DC:  DATA AD,16
00DD:  DATA 2D,10
00DE:  DATA 0A,10
00DF:  DATA 00,00
00E0:  DATA 20,10
00E1:  DATA D6,32
00E2:  DATA EC,37
00E3:  DATA E3,34
00E4:  DATA E4,30
00E5:  DATA 64,10
00E6:  DATA 33,10
00E7:  DATA 0A,10
00E8:  DATA 00,01
00E9:  DATA 20,10
00EA:  DATA D6,32
00EB:  DATA EC,37
00EC:  DATA E3,34
00ED:  DATA E4,30
00EE:  DATA 64,10
00EF:  DATA 32,10
00F0:  DATA 0A,10
00F1:  DATA 00,01
00F2:  DATA 20,10
00F3:  DATA D6,32
00F4:  DATA EC,37
00F5:  DATA E3,34
00F6:  DATA E4,30
00F7:  DATA 64,10
00F8:  DATA 31,10
00F9:  DATA 0A,10
00FA:  DATA 00,00
*
024F:  MOVF   0B,W
0250:  MOVWF  3A
0251:  BCF    0B.7
0252:  BSF    03.5
0253:  BSF    03.6
0254:  BSF    0C.7
0255:  BSF    0C.0
0256:  NOP
0257:  NOP
0258:  BCF    03.5
0259:  BCF    03.6
025A:  BTFSC  3A.7
025B:  BSF    0B.7
025C:  BSF    03.6
025D:  MOVF   0C,W
025E:  ANDLW  7F
025F:  BTFSC  03.2
0260:  GOTO   2A3
0261:  BCF    03.6
0262:  MOVWF  3A
0263:  BSF    03.6
0264:  MOVF   0D,W
0265:  BCF    03.6
0266:  MOVWF  3B
0267:  BSF    03.6
0268:  MOVF   0F,W
0269:  BCF    03.6
026A:  MOVWF  3C
026B:  MOVF   3A,W
026C:  MOVWF  3D
026D:  CALL   22A
026E:  MOVF   3B,W
026F:  BSF    03.6
0270:  MOVWF  0D
0271:  BCF    03.6
0272:  MOVF   3C,W
0273:  BSF    03.6
0274:  MOVWF  0F
0275:  BCF    03.6
0276:  MOVF   0B,W
0277:  MOVWF  3D
0278:  BCF    0B.7
0279:  BSF    03.5
027A:  BSF    03.6
027B:  BSF    0C.7
027C:  BSF    0C.0
027D:  NOP
027E:  NOP
027F:  BCF    03.5
0280:  BCF    03.6
0281:  BTFSC  3D.7
0282:  BSF    0B.7
0283:  BSF    03.6
0284:  RLF    0C,W
0285:  RLF    0E,W
0286:  ANDLW  7F
0287:  BTFSC  03.2
0288:  GOTO   2A3
0289:  BCF    03.6
028A:  MOVWF  3A
028B:  BSF    03.6
028C:  MOVF   0D,W
028D:  BCF    03.6
028E:  MOVWF  3B
028F:  BSF    03.6
0290:  MOVF   0F,W
0291:  BCF    03.6
0292:  MOVWF  3C
0293:  MOVF   3A,W
0294:  MOVWF  3D
0295:  CALL   22A
0296:  MOVF   3B,W
0297:  BSF    03.6
0298:  MOVWF  0D
0299:  BCF    03.6
029A:  MOVF   3C,W
029B:  BSF    03.6
029C:  MOVWF  0F
029D:  INCF   0D,F
029E:  BTFSC  03.2
029F:  INCF   0F,F
02A0:  BCF    03.6
02A1:  GOTO   24F
02A2:  BSF    03.6
02A3:  BCF    03.6
02A4:  RETURN
....................  
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT 
.................... #use delay(clock=20000000) 
*
0059:  MOVLW  4C
005A:  MOVWF  04
005B:  BCF    03.7
005C:  MOVF   00,W
005D:  BTFSC  03.2
005E:  GOTO   06C
005F:  MOVLW  06
0060:  MOVWF  78
0061:  CLRF   77
0062:  DECFSZ 77,F
0063:  GOTO   062
0064:  DECFSZ 78,F
0065:  GOTO   061
0066:  MOVLW  7B
0067:  MOVWF  77
0068:  DECFSZ 77,F
0069:  GOTO   068
006A:  DECFSZ 00,F
006B:  GOTO   05F
006C:  RETURN
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)              //Puerto Serie ->Bluetoth 
.................... #use i2c(MASTER, SDA=PIN_C4, SCL=PIN_C3,SLOW, NOFORCE_SW)    
*
00FB:  BCF    14.7
00FC:  BCF    0C.3
00FD:  MOVF   4B,W
00FE:  MOVWF  13
00FF:  MOVLW  02
0100:  BTFSC  14.7
0101:  GOTO   109
0102:  BTFSS  0C.3
0103:  GOTO   102
0104:  MOVLW  00
0105:  BSF    03.5
0106:  BTFSC  11.6
0107:  MOVLW  01
0108:  BCF    03.5
0109:  MOVWF  78
010A:  RETURN
.................... #include <i2c_Flex_LCD.c>                                   //LCD 
.................... //-----------------------------------------------------------------------------  
.................... // Title:         i2c_Flex_LCD  
.................... // Description:   Driver for common LCD with 1/2/3 or 4 rows by 1...20 columns  
.................... //                using PCF8574T interface board with I2C protocol.  
.................... // Date:          Nov-2013  
.................... // Ver.Rev.:      1.1  
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of  
.................... //                "20X4_LCD_I2C_DRIVER.h" from Pumrin S. and "lcd4_i2c.c" from XP8100  
.................... //-----------------------------------------------------------------------------  
.................... //  
.................... // lcd_init() Must be called before any other function.  
.................... //  
.................... // lcd_putc(c) Will display c on the next position of the LCD.  
.................... //   
.................... //     \f Clear LCD display  
.................... //     \n Set write position on next lcd line  
.................... //     \b LCD backspace  
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)  
.................... //  
.................... // lcd_backlight_led(ON)/lcd_backlight_led(OFF) = Turn ON/OFF LCD Backlight LED  
.................... //  
.................... //-----------------------------------------------------------------------------  
.................... // LCD pins D0-D3 are not used.  
.................... //-----------------------------------------------------------------------------  
.................... //  
.................... // Comment   : Control of a compatible LCD (1...4 rows by 1...4 columns) from  
.................... //              a bus I2C with an EXPANDER of I/O with connection I2C.  
.................... //              The tests of these routines have been programmed using the IC  
.................... //              Phillips PCF8574T. I've used 4 bits mode programming.  
.................... //              The 8 bits mode programming is possible if you use 2 x PCF8574T.  
.................... //              RW Pin is not being used.  
.................... //  
.................... // As defined in the following structure the pin connection is as follows:  
.................... //  
.................... //  PCF8574P     LCD  
.................... //  ========     ======  
.................... //     P0        RS  
.................... //     P1        RW    (Not used!)  
.................... //     P2        Enable   
.................... //     P3        Led Backlight  
.................... //     P4        D4  
.................... //     P5        D5  
.................... //     P6        D6  
.................... //     P7        D7  
.................... //  
.................... //  The SCL and SDA pins should be pull-up resistor as shown below:  
.................... //  
.................... //             +5v  
.................... //               |  
.................... //               <  
.................... //               > 4.7K         
.................... //               <           
.................... //To PIC         |          To i2c slave  
.................... //pin xx ------------------ SDA pin   
.................... //(SDA)                       
.................... //              +5v  
.................... //               |  
.................... //               <  
.................... //               > 4.7K         
.................... //               <           
.................... //To PIC         |          To i2c slave  
.................... //pin xx ------------------ SCL pin   
.................... //(SCL)  
.................... //  
.................... //To PIC                    To i2c slave  
.................... //Vss pin ----------------- Vss or ground pin   
.................... //                |  
.................... //              -----  
.................... //               ---  Ground  
.................... //                -   
.................... //   
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS"  
.................... //-----------------------------------------------------------------------------  
.................... byte LCD_ADDR ;//             0x4E        //I2C slave address for LCD module  
.................... byte lcd_total_rows ;//       2           //Number of rows: 1,2,3 or 4  
.................... byte lcd_total_columns ;//    16          //Number of columns: 1...20    
....................  
.................... #define RS                    0b00000001  //P0 - PCF8574T Pin connected to RS  
.................... #define RW                    0b00000010  //P1 - PCF8574T Pin connected to RW  
.................... #define ENABLE                0b00000100  //P2 - PCF8574T Pin connected to EN  
.................... #define LCD_BACKLIGHT         0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED  
....................  
.................... #define addr_row_one          0x00        //LCD RAM address for row 1  
.................... #define addr_row_two          0x40        //LCD RAM address for row 2  
.................... #define addr_row_three        0x14        //LCD RAM address for row 3  
.................... #define addr_row_four         0x54        //LCD RAM address for row 4  
....................  
.................... #define ON                    1  
.................... #define OFF                   0  
.................... #define NOT                   ~  
.................... #define data_shifted          data<<4  
.................... int8 new_row_request=1, BACKLIGHT_LED=LCD_BACKLIGHT;  
....................  
.................... void lcd_backlight_led(byte bl)  
.................... {   
....................       If (bl) BACKLIGHT_LED=LCD_BACKLIGHT; else BACKLIGHT_LED=OFF;  
.................... }  
....................  
.................... void i2c_send_nibble(byte data, byte type)  
.................... {     
....................    switch (type)  
010B:  MOVF   49,W
010C:  XORLW  00
010D:  BTFSC  03.2
010E:  GOTO   113
010F:  XORLW  01
0110:  BTFSC  03.2
0111:  GOTO   136
0112:  GOTO   15A
....................    {       
....................       case 0 :       
....................       i2c_write(data_shifted | BACKLIGHT_LED);  
0113:  SWAPF  48,W
0114:  MOVWF  77
0115:  MOVLW  F0
0116:  ANDWF  77,F
0117:  MOVF   77,W
0118:  IORWF  31,W
0119:  MOVWF  4A
011A:  MOVWF  4B
011B:  CALL   0FB
....................       delay_cycles(1);  
011C:  NOP
....................       i2c_write(data_shifted | ENABLE | BACKLIGHT_LED );  
011D:  SWAPF  48,W
011E:  MOVWF  77
011F:  MOVLW  F0
0120:  ANDWF  77,F
0121:  MOVF   77,W
0122:  IORLW  04
0123:  IORWF  31,W
0124:  MOVWF  4A
0125:  MOVWF  4B
0126:  CALL   0FB
....................       delay_us(2);  
0127:  MOVLW  03
0128:  MOVWF  77
0129:  DECFSZ 77,F
012A:  GOTO   129
....................       i2c_write(data_shifted & NOT ENABLE | BACKLIGHT_LED);  
012B:  SWAPF  48,W
012C:  MOVWF  77
012D:  MOVLW  F0
012E:  ANDWF  77,F
012F:  MOVF   77,W
0130:  ANDLW  FB
0131:  IORWF  31,W
0132:  MOVWF  4A
0133:  MOVWF  4B
0134:  CALL   0FB
....................       break;  
0135:  GOTO   15A
....................        
....................       case 1 :  
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED);  
0136:  SWAPF  48,W
0137:  MOVWF  77
0138:  MOVLW  F0
0139:  ANDWF  77,F
013A:  MOVF   77,W
013B:  IORLW  01
013C:  IORWF  31,W
013D:  MOVWF  4A
013E:  MOVWF  4B
013F:  CALL   0FB
....................       delay_cycles(1);  
0140:  NOP
....................       i2c_write(data_shifted | RS | ENABLE | BACKLIGHT_LED );  
0141:  SWAPF  48,W
0142:  MOVWF  77
0143:  MOVLW  F0
0144:  ANDWF  77,F
0145:  MOVF   77,W
0146:  IORLW  01
0147:  IORLW  04
0148:  IORWF  31,W
0149:  MOVWF  4A
014A:  MOVWF  4B
014B:  CALL   0FB
....................       delay_us(2);  
014C:  MOVLW  03
014D:  MOVWF  77
014E:  DECFSZ 77,F
014F:  GOTO   14E
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED);  
0150:  SWAPF  48,W
0151:  MOVWF  77
0152:  MOVLW  F0
0153:  ANDWF  77,F
0154:  MOVF   77,W
0155:  IORLW  01
0156:  IORWF  31,W
0157:  MOVWF  4A
0158:  MOVWF  4B
0159:  CALL   0FB
....................       break;  
....................    }  
015A:  RETURN
.................... }  
....................      
.................... void lcd_send_byte(byte data, byte type)  
....................    {  
....................         i2c_start();  
015B:  BSF    03.5
015C:  BSF    11.0
015D:  BTFSC  11.0
015E:  GOTO   15D
....................         i2c_write(LCD_ADDR);  
015F:  BCF    03.5
0160:  MOVF   2D,W
0161:  MOVWF  4B
0162:  CALL   0FB
....................         i2c_send_nibble(data >> 4 , type);  
0163:  SWAPF  45,W
0164:  MOVWF  47
0165:  MOVLW  0F
0166:  ANDWF  47,F
0167:  MOVF   47,W
0168:  MOVWF  48
0169:  MOVF   46,W
016A:  MOVWF  49
016B:  CALL   10B
....................         i2c_send_nibble(data & 0xf , type);  
016C:  MOVF   45,W
016D:  ANDLW  0F
016E:  MOVWF  47
016F:  MOVWF  48
0170:  MOVF   46,W
0171:  MOVWF  49
0172:  CALL   10B
....................         i2c_stop();         
0173:  BSF    03.5
0174:  BSF    11.2
0175:  BTFSC  11.2
0176:  GOTO   175
0177:  BCF    03.5
0178:  RETURN
....................    }  
....................  
.................... void lcd_clear()  
.................... {   
....................         lcd_send_byte(0x01,0);  
0179:  MOVLW  01
017A:  MOVWF  45
017B:  CLRF   46
017C:  CALL   15B
017D:  CLRF   2B
017E:  BTFSC  0B.7
017F:  BSF    2B.7
0180:  BCF    0B.7
....................         delay_ms(2);  
0181:  MOVLW  02
0182:  MOVWF  4C
0183:  CALL   059
0184:  BTFSC  2B.7
0185:  BSF    0B.7
....................         new_row_request=1;  
0186:  MOVLW  01
0187:  MOVWF  30
0188:  RETURN
.................... }  
....................  
.................... void lcd_init(byte ADDR, byte col, byte row)  
.................... {  
....................    byte i; 
....................    byte CONST lcd_type=2;  // 0=5x7, 1=5x10, 2=2 lines  
....................    byte CONST LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; // These bytes need to be sent to the LCD to start it up. 
....................     
....................    LCD_ADDR =ADDR;//             0x4E        //I2C slave address for LCD module  
0189:  MOVF   3A,W
018A:  MOVWF  2D
....................    lcd_total_rows =row;//       2           //Number of rows: 1,2,3 or 4  
018B:  MOVF   3C,W
018C:  MOVWF  2E
....................    lcd_total_columns= col ; 
018D:  MOVF   3B,W
018E:  MOVWF  2F
....................    disable_interrupts(GLOBAL);  
018F:  BCF    0B.6
0190:  BCF    0B.7
0191:  BTFSC  0B.7
0192:  GOTO   190
0193:  CLRF   2B
0194:  BTFSC  0B.7
0195:  BSF    2B.7
0196:  BCF    0B.7
....................    delay_ms(50); //LCD power up delay  
0197:  MOVLW  32
0198:  MOVWF  4C
0199:  CALL   059
019A:  BTFSC  2B.7
019B:  BSF    0B.7
....................      
....................    i2c_start();  
019C:  BSF    03.5
019D:  BSF    11.0
019E:  BTFSC  11.0
019F:  GOTO   19E
....................    i2c_write(LCD_ADDR);  
01A0:  BCF    03.5
01A1:  MOVF   2D,W
01A2:  MOVWF  4B
01A3:  CALL   0FB
....................       i2c_send_nibble(0x00,0);  
01A4:  CLRF   48
01A5:  CLRF   49
01A6:  CALL   10B
01A7:  CLRF   2B
01A8:  BTFSC  0B.7
01A9:  BSF    2B.7
01AA:  BCF    0B.7
....................       delay_ms(15);  
01AB:  MOVLW  0F
01AC:  MOVWF  4C
01AD:  CALL   059
01AE:  BTFSC  2B.7
01AF:  BSF    0B.7
....................      
....................    for (i=1;i<=3;++i)     
01B0:  MOVLW  01
01B1:  MOVWF  3D
01B2:  MOVF   3D,W
01B3:  SUBLW  03
01B4:  BTFSS  03.0
01B5:  GOTO   1C5
....................    {  
....................       i2c_send_nibble(0x03,0);  
01B6:  MOVLW  03
01B7:  MOVWF  48
01B8:  CLRF   49
01B9:  CALL   10B
01BA:  CLRF   2B
01BB:  BTFSC  0B.7
01BC:  BSF    2B.7
01BD:  BCF    0B.7
....................       delay_ms(5);  
01BE:  MOVLW  05
01BF:  MOVWF  4C
01C0:  CALL   059
01C1:  BTFSC  2B.7
01C2:  BSF    0B.7
01C3:  INCF   3D,F
01C4:  GOTO   1B2
....................    }     
....................       i2c_send_nibble(0x02,0);  
01C5:  MOVLW  02
01C6:  MOVWF  48
01C7:  CLRF   49
01C8:  CALL   10B
01C9:  CLRF   2B
01CA:  BTFSC  0B.7
01CB:  BSF    2B.7
01CC:  BCF    0B.7
....................       delay_ms(5);  
01CD:  MOVLW  05
01CE:  MOVWF  4C
01CF:  CALL   059
01D0:  BTFSC  2B.7
01D1:  BSF    0B.7
....................    i2c_stop();  
01D2:  BSF    03.5
01D3:  BSF    11.2
01D4:  BTFSC  11.2
01D5:  GOTO   1D4
....................      
....................    for (i=0;i<=3;++i) {  
01D6:  BCF    03.5
01D7:  CLRF   3D
01D8:  MOVF   3D,W
01D9:  SUBLW  03
01DA:  BTFSS  03.0
01DB:  GOTO   1ED
....................    lcd_send_byte(LCD_INIT_STRING[i],0);  
01DC:  MOVF   3D,W
01DD:  CALL   051
01DE:  MOVWF  3E
01DF:  MOVWF  45
01E0:  CLRF   46
01E1:  CALL   15B
01E2:  CLRF   2B
01E3:  BTFSC  0B.7
01E4:  BSF    2B.7
01E5:  BCF    0B.7
....................    delay_ms(5);  
01E6:  MOVLW  05
01E7:  MOVWF  4C
01E8:  CALL   059
01E9:  BTFSC  2B.7
01EA:  BSF    0B.7
01EB:  INCF   3D,F
01EC:  GOTO   1D8
....................    }  
....................    lcd_clear();  //Clear Display  
01ED:  CALL   179
....................    enable_interrupts(GLOBAL);  
01EE:  MOVLW  C0
01EF:  IORWF  0B,F
01F0:  BCF    0A.3
01F1:  BCF    0A.4
01F2:  GOTO   2F9 (RETURN)
.................... }  
....................  
.................... void lcd_gotoxy( byte x, byte y)  
.................... {  
.................... byte row,column,row_addr,lcd_address;  
.................... static char data;  
*
02D5:  BCF    03.5
02D6:  CLRF   32
....................  
....................    if (y>lcd_total_rows) row=lcd_total_rows; else row=y;  
*
01F3:  MOVF   3F,W
01F4:  SUBWF  2E,W
01F5:  BTFSC  03.0
01F6:  GOTO   1FA
01F7:  MOVF   2E,W
01F8:  MOVWF  40
01F9:  GOTO   1FC
01FA:  MOVF   3F,W
01FB:  MOVWF  40
....................    
....................    switch(row)  
01FC:  MOVF   40,W
01FD:  XORLW  01
01FE:  BTFSC  03.2
01FF:  GOTO   20A
0200:  XORLW  03
0201:  BTFSC  03.2
0202:  GOTO   20C
0203:  XORLW  01
0204:  BTFSC  03.2
0205:  GOTO   20F
0206:  XORLW  07
0207:  BTFSC  03.2
0208:  GOTO   212
0209:  GOTO   215
....................    {  
....................       case 1:  row_addr=addr_row_one;     break;  
020A:  CLRF   42
020B:  GOTO   216
....................       case 2:  row_addr=addr_row_two;     break;  
020C:  MOVLW  40
020D:  MOVWF  42
020E:  GOTO   216
....................       case 3:  row_addr=addr_row_three;   break;  
020F:  MOVLW  14
0210:  MOVWF  42
0211:  GOTO   216
....................       case 4:  row_addr=addr_row_four;    break;  
0212:  MOVLW  54
0213:  MOVWF  42
0214:  GOTO   216
....................       default: row_addr=addr_row_one;     break;   
0215:  CLRF   42
....................    }   
....................      
....................    if (x>lcd_total_columns) column=lcd_total_columns; else column=x;   
0216:  MOVF   3E,W
0217:  SUBWF  2F,W
0218:  BTFSC  03.0
0219:  GOTO   21D
021A:  MOVF   2F,W
021B:  MOVWF  41
021C:  GOTO   21F
021D:  MOVF   3E,W
021E:  MOVWF  41
....................    lcd_address=(row_addr+(column-1));  
021F:  MOVLW  01
0220:  SUBWF  41,W
0221:  ADDWF  42,W
0222:  MOVWF  43
....................    lcd_send_byte(0x80|lcd_address,0);  
0223:  MOVF   43,W
0224:  IORLW  80
0225:  MOVWF  44
0226:  MOVWF  45
0227:  CLRF   46
0228:  CALL   15B
0229:  RETURN
.................... }  
....................  
.................... //Display the character on LCD screen.  
.................... void LCD_PUTC(char in_data)  
.................... {     
....................   switch(in_data)  
022A:  MOVF   3D,W
022B:  XORLW  0C
022C:  BTFSC  03.2
022D:  GOTO   235
022E:  XORLW  06
022F:  BTFSC  03.2
0230:  GOTO   237
0231:  XORLW  02
0232:  BTFSC  03.2
0233:  GOTO   244
0234:  GOTO   249
....................    {   
....................      case '\f': lcd_clear();                       break;                 
0235:  CALL   179
0236:  GOTO   24E
....................        
....................      case '\n':  
....................      new_row_request++;  
0237:  INCF   30,F
....................      if (new_row_request>lcd_total_rows) new_row_request=1;  
0238:  MOVF   30,W
0239:  SUBWF  2E,W
023A:  BTFSC  03.0
023B:  GOTO   23E
023C:  MOVLW  01
023D:  MOVWF  30
....................      lcd_gotoxy(1, new_row_request);  
023E:  MOVLW  01
023F:  MOVWF  3E
0240:  MOVF   30,W
0241:  MOVWF  3F
0242:  CALL   1F3
....................      break;  
0243:  GOTO   24E
....................                    
....................      case '\b': lcd_send_byte(0x10,0);             break;  
0244:  MOVLW  10
0245:  MOVWF  45
0246:  CLRF   46
0247:  CALL   15B
0248:  GOTO   24E
....................          
....................      default: lcd_send_byte(in_data,1);            break;       
0249:  MOVF   3D,W
024A:  MOVWF  45
024B:  MOVLW  01
024C:  MOVWF  46
024D:  CALL   15B
....................        
....................    }  
024E:  RETURN
.................... }  
....................  
.................... #org 0x1F00,0x1FFF void loader16F877(void){}                //Terminal 
*
1F00:  RETURN
....................  
.................... /// === Vaiable Globales === 
.................... int direccion=0,movCoche=0; 
.................... int velocidad=1,changeVel=0; 
.................... char b; 
....................  
.................... #int_RDA       //Se recbio un dato 
.................... void direcCarro(){ 
....................    b = getchar(); 
*
006D:  BTFSS  0C.5
006E:  GOTO   06D
006F:  MOVF   1A,W
0070:  MOVWF  37
....................    if(b == 'S'){     //Para: 0 
0071:  MOVF   37,W
0072:  SUBLW  53
0073:  BTFSC  03.2
....................       direccion = 0; 
0074:  CLRF   33
....................    } 
....................    if(b == 'A'){     //Hacia adelante: 1  
0075:  MOVF   37,W
0076:  SUBLW  41
0077:  BTFSS  03.2
0078:  GOTO   07B
....................       direccion = 1;        //1010 -> M1=DERECHA M2=DERECHA 
0079:  MOVLW  01
007A:  MOVWF  33
....................    } 
....................    if(b == 'R'){     //Hacia atras: 2 
007B:  MOVF   37,W
007C:  SUBLW  52
007D:  BTFSS  03.2
007E:  GOTO   081
....................       direccion = 2;         //0101 -> M1=IZQUIERDA M2=IZQUIERDA 
007F:  MOVLW  02
0080:  MOVWF  33
....................    } 
....................    if(b == 'I'){     //Hacia la izquierda: 3 
0081:  MOVF   37,W
0082:  SUBLW  49
0083:  BTFSS  03.2
0084:  GOTO   087
....................       direccion = 3;         //0110 -> M1=IZQUIERDA M2=DERECHA 
0085:  MOVLW  03
0086:  MOVWF  33
....................    } 
....................    if(b == 'D'){     //Hacia derecha: 4 
0087:  MOVF   37,W
0088:  SUBLW  44
0089:  BTFSS  03.2
008A:  GOTO   08D
....................       direccion = 4;         //1001 -> M1=DERECHA M2=IZQUIERDA 
008B:  MOVLW  04
008C:  MOVWF  33
....................    } 
....................    if(b=='F'){ //aumenta la velocidad 
008D:  MOVF   37,W
008E:  SUBLW  46
008F:  BTFSS  03.2
0090:  GOTO   098
....................       if(velocidad<3){ 
0091:  MOVF   35,W
0092:  SUBLW  02
0093:  BTFSS  03.0
0094:  GOTO   098
....................          velocidad+=1; 
0095:  MOVLW  01
0096:  ADDWF  35,F
....................          changeVel=1; 
0097:  MOVWF  36
....................       } 
....................    } 
....................    if(b=='L'){ 
0098:  MOVF   37,W
0099:  SUBLW  4C
009A:  BTFSS  03.2
009B:  GOTO   0A3
....................       if(velocidad>1){ 
009C:  MOVF   35,W
009D:  SUBLW  01
009E:  BTFSC  03.0
009F:  GOTO   0A3
....................          changeVel=1; 
00A0:  MOVLW  01
00A1:  MOVWF  36
....................          velocidad-=1; 
00A2:  SUBWF  35,F
....................       } 
....................    } 
....................    delay_ms(100);// retardo de 100ms para que se pueda apreciar el cambio 
00A3:  MOVLW  64
00A4:  MOVWF  4C
00A5:  CALL   059
00A6:  BCF    0C.5
00A7:  BCF    0A.3
00A8:  BCF    0A.4
00A9:  GOTO   02D
.................... } 
.................... void escribir_i2c(){ 
....................    i2c_start();//inicia comunicaci{on 
....................    i2c_write(0x42);//direccion recorrida un lugar 
....................    i2c_write(0); //envia a escribir el contenido de contador 
....................    i2c_stop();//detiene comunicacion 
.................... } 
.................... void cambioVelocidad(); 
.................... void movMotores(); 
.................... void main(){ 
*
02A5:  MOVF   03,W
02A6:  ANDLW  1F
02A7:  MOVWF  03
02A8:  MOVLW  81
02A9:  BSF    03.5
02AA:  MOVWF  19
02AB:  MOVLW  A6
02AC:  MOVWF  18
02AD:  MOVLW  90
02AE:  BCF    03.5
02AF:  MOVWF  18
02B0:  MOVLW  FF
02B1:  MOVWF  2C
02B2:  BSF    2C.3
02B3:  MOVF   2C,W
02B4:  BSF    03.5
02B5:  MOVWF  07
02B6:  BCF    03.5
02B7:  BSF    2C.4
02B8:  MOVF   2C,W
02B9:  BSF    03.5
02BA:  MOVWF  07
02BB:  MOVLW  31
02BC:  MOVWF  13
02BD:  MOVLW  28
02BE:  BCF    03.5
02BF:  MOVWF  14
02C0:  BSF    03.5
02C1:  BSF    14.7
02C2:  BCF    14.6
02C3:  MOVLW  01
02C4:  BCF    03.5
02C5:  MOVWF  30
02C6:  MOVLW  08
02C7:  MOVWF  31
02C8:  CLRF   33
02C9:  CLRF   34
02CA:  MOVLW  01
02CB:  MOVWF  35
02CC:  CLRF   36
02CD:  CLRF   39
02CE:  CLRF   38
02CF:  BSF    03.5
02D0:  BSF    1F.0
02D1:  BSF    1F.1
02D2:  BSF    1F.2
02D3:  BCF    1F.3
02D4:  BCF    03.7
....................    //=== Interrupciones === 
....................    enable_interrupts(INT_RDA);    //Habilita interrupción detección por puerto serie 
02D7:  BSF    03.5
02D8:  BSF    0C.5
....................    enable_interrupts(GLOBAL); 
02D9:  MOVLW  C0
02DA:  BCF    03.5
02DB:  IORWF  0B,F
....................    setup_timer_2(t2_div_by_16,255,1);//predivisor de 16, PR2=255,  con esto tenemos un periodo de 0.8192ms y frecuencia de 1.22kHZ 
02DC:  MOVLW  00
02DD:  MOVWF  78
02DE:  IORLW  06
02DF:  MOVWF  12
02E0:  MOVLW  FF
02E1:  BSF    03.5
02E2:  MOVWF  12
....................    setup_ccp1(ccp_pwm); 
02E3:  BCF    03.5
02E4:  BCF    2C.2
02E5:  MOVF   2C,W
02E6:  BSF    03.5
02E7:  MOVWF  07
02E8:  BCF    03.5
02E9:  BCF    07.2
02EA:  MOVLW  0C
02EB:  MOVWF  17
....................    set_tris_b(0xF0); //4 bits menos significativos como salida y los 4 bits más significativos como entrada 
02EC:  MOVLW  F0
02ED:  BSF    03.5
02EE:  MOVWF  06
....................    output_d(0x00);// MUESTRA CERO EN DISPLAY 
02EF:  CLRF   08
02F0:  BCF    03.5
02F1:  CLRF   08
....................    lcd_init(0x4E,16,2);       // Ajustar de acuerdo a las conexiones (consultar imagen) 
02F2:  MOVLW  4E
02F3:  MOVWF  3A
02F4:  MOVLW  10
02F5:  MOVWF  3B
02F6:  MOVLW  02
02F7:  MOVWF  3C
02F8:  GOTO   189
....................    //escribir_i2c(); 
....................    lcd_gotoxy(1,1);  
02F9:  MOVLW  01
02FA:  MOVWF  3E
02FB:  MOVWF  3F
02FC:  CALL   1F3
....................    printf(lcd_putc," Prueba \n ");  //imprimimos el mensaje \n hace cambio de fila 
02FD:  MOVLW  AA
02FE:  BSF    03.6
02FF:  MOVWF  0D
0300:  MOVLW  00
0301:  MOVWF  0F
0302:  BCF    03.6
0303:  CALL   24F
0304:  CLRF   2B
0305:  BTFSC  0B.7
0306:  BSF    2B.7
0307:  BCF    0B.7
....................    delay_ms(100);  
0308:  MOVLW  64
0309:  MOVWF  4C
030A:  CALL   059
030B:  BTFSC  2B.7
030C:  BSF    0B.7
....................    
....................    while(TRUE){ 
....................       movMotores(); 
....................       if(changeVel==1)cambioVelocidad(); 
*
03BE:  DECFSZ 36,W
03BF:  GOTO   402
*
0402:  GOTO   30D
....................        
....................    } 
.................... } 
.................... void movMotores(){ 
0403:  SLEEP
....................    switch(direccion){ 
*
030D:  MOVF   33,W
030E:  BTFSC  03.2
030F:  GOTO   31D
0310:  XORLW  01
0311:  BTFSC  03.2
0312:  GOTO   32E
0313:  XORLW  03
0314:  BTFSC  03.2
0315:  GOTO   352
0316:  XORLW  01
0317:  BTFSC  03.2
0318:  GOTO   376
0319:  XORLW  07
031A:  BTFSC  03.2
031B:  GOTO   39A
031C:  GOTO   3BE
....................       case 0: //Alto 
....................          output_b(0x0F);   //limpiamos puerto B  0000 0000 no hay movimiento de los motores 
031D:  BSF    03.5
031E:  CLRF   06
031F:  MOVLW  0F
0320:  BCF    03.5
0321:  MOVWF  06
....................          lcd_gotoxy(1,1); 
0322:  MOVLW  01
0323:  MOVWF  3E
0324:  MOVWF  3F
0325:  CALL   1F3
....................          printf(lcd_putc,"----Alto---- \n "); 
0326:  MOVLW  B0
0327:  BSF    03.6
0328:  MOVWF  0D
0329:  MOVLW  00
032A:  MOVWF  0F
032B:  BCF    03.6
032C:  CALL   24F
....................          break;    
032D:  GOTO   3BE
....................       case 1:  //Avanza: 1010:  M1:derecha, M2: derecha 
....................          //output_bit(PIN_B0,0); 
....................          output_bit(PIN_B0,input_state(pin_C2)); 
032E:  BTFSC  07.2
032F:  GOTO   332
0330:  BCF    06.0
0331:  GOTO   333
0332:  BSF    06.0
0333:  BSF    03.5
0334:  BCF    06.0
....................          output_bit(PIN_B1,1); 
0335:  BCF    03.5
0336:  BSF    06.1
0337:  BSF    03.5
0338:  BCF    06.1
....................          output_bit(PIN_B2,input_state(pin_C2)); 
0339:  BCF    03.5
033A:  BTFSC  07.2
033B:  GOTO   33E
033C:  BCF    06.2
033D:  GOTO   33F
033E:  BSF    06.2
033F:  BSF    03.5
0340:  BCF    06.2
....................          //output_bit(PIN_B2,0); 
....................          output_bit(PIN_B3,1); 
0341:  BCF    03.5
0342:  BSF    06.3
0343:  BSF    03.5
0344:  BCF    06.3
....................          lcd_gotoxy(1,1); 
0345:  MOVLW  01
0346:  BCF    03.5
0347:  MOVWF  3E
0348:  MOVWF  3F
0349:  CALL   1F3
....................          printf(lcd_putc,"  Avanza----- \n "); 
034A:  MOVLW  B8
034B:  BSF    03.6
034C:  MOVWF  0D
034D:  MOVLW  00
034E:  MOVWF  0F
034F:  BCF    03.6
0350:  CALL   24F
....................          break; 
0351:  GOTO   3BE
....................       case 2:   //Retrocede: 0101:  M1:izquierda, M2: izquierda 
....................          output_bit(PIN_B0,1); 
0352:  BSF    06.0
0353:  BSF    03.5
0354:  BCF    06.0
....................          output_bit(PIN_B1,input_state(pin_C2)); 
0355:  BCF    03.5
0356:  BTFSC  07.2
0357:  GOTO   35A
0358:  BCF    06.1
0359:  GOTO   35B
035A:  BSF    06.1
035B:  BSF    03.5
035C:  BCF    06.1
....................          //output_bit(PIN_B1,0); 
....................          output_bit(PIN_B2,1); 
035D:  BCF    03.5
035E:  BSF    06.2
035F:  BSF    03.5
0360:  BCF    06.2
....................          output_bit(PIN_B3,input_state(pin_C2)); 
0361:  BCF    03.5
0362:  BTFSC  07.2
0363:  GOTO   366
0364:  BCF    06.3
0365:  GOTO   367
0366:  BSF    06.3
0367:  BSF    03.5
0368:  BCF    06.3
....................          //output_bit(PIN_B3,0); 
....................          lcd_gotoxy(1,1); 
0369:  MOVLW  01
036A:  BCF    03.5
036B:  MOVWF  3E
036C:  MOVWF  3F
036D:  CALL   1F3
....................          printf(lcd_putc,"  Retrocede----- \n "); 
036E:  MOVLW  C1
036F:  BSF    03.6
0370:  MOVWF  0D
0371:  MOVLW  00
0372:  MOVWF  0F
0373:  BCF    03.6
0374:  CALL   24F
....................          break; 
0375:  GOTO   3BE
....................       case 3:   //Izquierda: 0110:  M1:izquierda, M2: izquierda 
....................          output_bit(PIN_B0,input_state(pin_C2)); 
0376:  BTFSC  07.2
0377:  GOTO   37A
0378:  BCF    06.0
0379:  GOTO   37B
037A:  BSF    06.0
037B:  BSF    03.5
037C:  BCF    06.0
....................          //output_bit(PIN_B0,0); 
....................          output_bit(PIN_B0,1); 
037D:  BCF    03.5
037E:  BSF    06.0
037F:  BSF    03.5
0380:  BCF    06.0
....................          output_bit(PIN_B2,1); 
0381:  BCF    03.5
0382:  BSF    06.2
0383:  BSF    03.5
0384:  BCF    06.2
....................          output_bit(PIN_B3,input_state(pin_C2)); 
0385:  BCF    03.5
0386:  BTFSC  07.2
0387:  GOTO   38A
0388:  BCF    06.3
0389:  GOTO   38B
038A:  BSF    06.3
038B:  BSF    03.5
038C:  BCF    06.3
....................          //output_bit(PIN_B3,0); 
....................          lcd_gotoxy(1,1); 
038D:  MOVLW  01
038E:  BCF    03.5
038F:  MOVWF  3E
0390:  MOVWF  3F
0391:  CALL   1F3
....................          printf(lcd_putc,"  Izquierda------ \n "); 
0392:  MOVLW  CB
0393:  BSF    03.6
0394:  MOVWF  0D
0395:  MOVLW  00
0396:  MOVWF  0F
0397:  BCF    03.6
0398:  CALL   24F
....................          break; 
0399:  GOTO   3BE
....................       case 4:  //Derecha: 1001:  M1:derecha, M2: derecha 
....................          output_bit(PIN_B0,1); 
039A:  BSF    06.0
039B:  BSF    03.5
039C:  BCF    06.0
....................          output_bit(PIN_B1,input_state(pin_C2)); 
039D:  BCF    03.5
039E:  BTFSC  07.2
039F:  GOTO   3A2
03A0:  BCF    06.1
03A1:  GOTO   3A3
03A2:  BSF    06.1
03A3:  BSF    03.5
03A4:  BCF    06.1
....................          //output_bit(PIN_B1,0); 
....................          output_bit(PIN_B2,input_state(pin_C2)); 
03A5:  BCF    03.5
03A6:  BTFSC  07.2
03A7:  GOTO   3AA
03A8:  BCF    06.2
03A9:  GOTO   3AB
03AA:  BSF    06.2
03AB:  BSF    03.5
03AC:  BCF    06.2
....................          //output_bit(PIN_B2,0); 
....................          output_bit(PIN_B3,1); 
03AD:  BCF    03.5
03AE:  BSF    06.3
03AF:  BSF    03.5
03B0:  BCF    06.3
....................          lcd_gotoxy(1,1); 
03B1:  MOVLW  01
03B2:  BCF    03.5
03B3:  MOVWF  3E
03B4:  MOVWF  3F
03B5:  CALL   1F3
....................          printf(lcd_putc,"  Derecha------ \n "); 
03B6:  MOVLW  D6
03B7:  BSF    03.6
03B8:  MOVWF  0D
03B9:  MOVLW  00
03BA:  MOVWF  0F
03BB:  BCF    03.6
03BC:  CALL   24F
....................          break;       
03BD:  GOTO   3BE
....................           
....................       default: 
....................          break; 
....................    } 
.................... } 
.................... void cambioVelocidad(){ 
....................    switch(velocidad){ 
03C0:  MOVF   35,W
03C1:  XORLW  01
03C2:  BTFSC  03.2
03C3:  GOTO   3CB
03C4:  XORLW  03
03C5:  BTFSC  03.2
03C6:  GOTO   3DA
03C7:  XORLW  01
03C8:  BTFSC  03.2
03C9:  GOTO   3E9
03CA:  GOTO   3F8
....................       case 1: 
....................          set_pwm1_duty(20); 
03CB:  MOVLW  14
03CC:  MOVWF  15
....................          lcd_gotoxy(1,2); 
03CD:  MOVLW  01
03CE:  MOVWF  3E
03CF:  MOVLW  02
03D0:  MOVWF  3F
03D1:  CALL   1F3
....................          printf(lcd_putc,"  Velocidad 3 \n "); 
03D2:  MOVLW  E0
03D3:  BSF    03.6
03D4:  MOVWF  0D
03D5:  MOVLW  00
03D6:  MOVWF  0F
03D7:  BCF    03.6
03D8:  CALL   24F
....................          break;    
03D9:  GOTO   3F8
....................       case 2:   
....................          set_pwm1_duty(60); 
03DA:  MOVLW  3C
03DB:  MOVWF  15
....................          lcd_gotoxy(1,2); 
03DC:  MOVLW  01
03DD:  MOVWF  3E
03DE:  MOVLW  02
03DF:  MOVWF  3F
03E0:  CALL   1F3
....................          printf(lcd_putc,"  Velocidad 2 \n "); 
03E1:  MOVLW  E9
03E2:  BSF    03.6
03E3:  MOVWF  0D
03E4:  MOVLW  00
03E5:  MOVWF  0F
03E6:  BCF    03.6
03E7:  CALL   24F
....................          break; 
03E8:  GOTO   3F8
....................       case 3:   
....................          set_pwm1_duty(127); 
03E9:  MOVLW  7F
03EA:  MOVWF  15
....................          lcd_gotoxy(1,2); 
03EB:  MOVLW  01
03EC:  MOVWF  3E
03ED:  MOVLW  02
03EE:  MOVWF  3F
03EF:  CALL   1F3
....................          printf(lcd_putc,"  Velocidad 1 \n "); 
03F0:  MOVLW  F2
03F1:  BSF    03.6
03F2:  MOVWF  0D
03F3:  MOVLW  00
03F4:  MOVWF  0F
03F5:  BCF    03.6
03F6:  CALL   24F
....................          break; 
03F7:  GOTO   3F8
....................       default: 
....................          break; 
....................    } 
....................    changeVel=0; //reiniciamos la bandera de velocidad para permitir otros cambios de velocidad 
03F8:  CLRF   36
03F9:  CLRF   2B
03FA:  BTFSC  0B.7
03FB:  BSF    2B.7
03FC:  BCF    0B.7
....................    delay_ms(100); 
03FD:  MOVLW  64
03FE:  MOVWF  4C
03FF:  CALL   059
0400:  BTFSC  2B.7
0401:  BSF    0B.7
....................     
....................     
.................... } 

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
